AMGX,RTX3090,64x64x64,SymGS
"ID","Process ID","Process Name","Host Name","Kernel Name","Context","Stream","Block Size","Grid Size","Device","CC","Section Name","Metric Name","Metric Unit","Metric Value","Rule Name","Rule Type","Rule Description"
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.62",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.37",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","52'788",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.22",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.22",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","38.37",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.36",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.49",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","45'883.72",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","68.03",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 54% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","9.99",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","78.22",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (78.2%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (78.2%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","186.64",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.49",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.22",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","22.46",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","22.86",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","22.01",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.10",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.90",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.10",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.17",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.9 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.10 active warps per scheduler, but only an average of 0.17 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","90.10",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","92.86",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.32",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","20.67",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 39.2 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.5% of the total average of 90.1 cycles between issuing two instructions."
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.3 threads being active per cycle. This is further reduced to 20.7 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","4'448.79",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'459'204",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","4'585.20",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'503'947",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 97380 fused and 75740 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.95",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.98",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.9%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","194'624",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","65.98",
"0","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 72630 excessive sectors (21% of the total 346759 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.56",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.37",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","52'863",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.13",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.13",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","38.62",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.34",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.42",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","45'779.85",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","67.62",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 53% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","9.98",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","78.05",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (78.1%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (78.1%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","184.81",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.42",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.13",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","22.35",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","22.80",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","21.88",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.11",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.89",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.11",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.17",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.9 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.11 active warps per scheduler, but only an average of 0.17 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","90.11",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","92.88",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.33",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","20.68",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 39.1 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.4% of the total average of 90.1 cycles between issuing two instructions."
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.3 threads being active per cycle. This is further reduced to 20.7 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","4'432.26",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'453'780",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","4'568.52",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'498'473",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 96948 fused and 75404 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","75.03",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","36.01",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (75.0%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","193'856",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","65.68",
"1","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 71753 excessive sectors (21% of the total 344784 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.48",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","46'233",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","21.24",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","21.24",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","34.08",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.33",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","12.04",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","41'892.22",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","69.46",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 15% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 55% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.35",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.00",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","76.62",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (76.6%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (76.6%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","193.34",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","12.04",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","21.24",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.66",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","22.43",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","22.47",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.14",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.86",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.02",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.17",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.9 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.02 active warps per scheduler, but only an average of 0.17 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","88.99",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","91.91",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.55",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","20.90",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 38.4 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.1% of the total average of 89.0 cycles between issuing two instructions."
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.5 threads being active per cycle. This is further reduced to 20.9 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","4'054.67",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'329'932",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","4'187.59",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'373'528",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 87084 fused and 67732 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.51",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.77",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.5%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","176'320",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","59",
"2","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 64953 excessive sectors (21% of the total 310969 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.51",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","46'371",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","21.15",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","21.15",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","34.08",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.34",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","12.00",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","41'810.88",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","69.13",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 15% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 55% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.35",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.00",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","76.62",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (76.6%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (76.6%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","193.04",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","12.00",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","21.15",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.78",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","22.46",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","22.37",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.14",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.86",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.03",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.17",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.9 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.03 active warps per scheduler, but only an average of 0.17 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","89.06",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","91.98",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.55",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","20.90",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 38.4 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.1% of the total average of 89.1 cycles between issuing two instructions."
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.5 threads being active per cycle. This is further reduced to 20.9 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","4'048.47",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'327'898",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","4'181.34",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'371'479",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 86922 fused and 67606 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.58",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.80",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.6%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","176'032",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","58.89",
"3","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 65870 excessive sectors (21% of the total 311233 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.49",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","46'198",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.84",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.84",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","34.02",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.46",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.66",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","40'376.46",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","67.17",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 53% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.09",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","76.81",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (76.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (76.8%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","189.92",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.66",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.84",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.77",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","21.99",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","21.73",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.21",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.79",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.04",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.17",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.04 active warps per scheduler, but only an average of 0.17 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","88.54",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","91.50",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.62",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","20.98",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 38.2 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.1% of the total average of 88.5 cycles between issuing two instructions."
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.6 threads being active per cycle. This is further reduced to 21.0 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'942.02",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'292'981",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","4'073.96",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'336'259",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 84141 fused and 65443 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.87",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.94",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.9%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","171'088",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","57.01",
"4","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 63112 excessive sectors (21% of the total 301065 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.49",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","46'129",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.70",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.70",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","33.95",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.49",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.59",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","40'032.50",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","66.74",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 53% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.11",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","76.85",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (76.9%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (76.9%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","188.63",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.59",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.70",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.86",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","21.84",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","21.59",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.23",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.77",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.06",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.17",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.06 active warps per scheduler, but only an average of 0.17 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","88.58",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","91.56",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.64",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","20.99",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 38.1 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.0% of the total average of 88.6 cycles between issuing two instructions."
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.6 threads being active per cycle. This is further reduced to 21.0 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'916.52",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'284'619",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","4'048.23",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'327'821",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 83475 fused and 64925 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.90",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.95",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.9%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","169'904",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","56.55",
"5","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 62970 excessive sectors (21% of the total 299002 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.47",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","45'780",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.12",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.12",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","33.76",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.46",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.31",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","38'885.12",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","64.73",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 51% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.10",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","76.16",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (76.2%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (76.2%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","182.94",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.31",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.12",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.54",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","21.44",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","20.94",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.26",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.74",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.03",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.03 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","87.98",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","91.01",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.71",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.08",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 37.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.1% of the total average of 88.0 cycles between issuing two instructions."
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.7 threads being active per cycle. This is further reduced to 21.1 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'796.98",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'245'408",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'927.61",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'288'256",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 80352 fused and 62496 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.38",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.70",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.4%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","164'352",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","54.44",
"6","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 60866 excessive sectors (21% of the total 288259 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.47",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","45'878",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.08",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.08",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","33.86",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.50",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.26",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","38'774.32",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","64.58",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 51% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.13",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","76.36",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (76.4%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (76.4%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","182.57",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.26",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.08",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.53",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","21.49",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","20.89",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.26",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.74",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.07",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.07 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","88.41",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","91.46",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.71",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.07",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 37.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.9% of the total average of 88.4 cycles between issuing two instructions."
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.7 threads being active per cycle. This is further reduced to 21.1 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'796.29",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'245'182",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'926.92",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'288'029",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 80334 fused and 62482 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.67",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.84",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.7%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","164'320",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","54.43",
"7","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 60365 excessive sectors (21% of the total 287631 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.46",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","40'063",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","22.19",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","22.19",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.60",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.51",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","12.40",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","37'451.79",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","70.94",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 15% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 56% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.37",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.15",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","75.83",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (75.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (75.8%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","201.50",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","12.40",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","22.19",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.55",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","20.99",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","22.95",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.29",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.71",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.00",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.00 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","87.42",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.50",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.80",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.16",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 37.6 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.0% of the total average of 87.4 cycles between issuing two instructions."
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.8 threads being active per cycle. This is further reduced to 21.2 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'670.88",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'204'050",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'800.41",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'246'535",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 77058 fused and 59934 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.44",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.73",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.4%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","158'496",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","52.21",
"8","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 58148 excessive sectors (21% of the total 276200 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.49",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","42'769",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.98",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.98",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","31.46",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.49",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.68",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","37'723.04",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","66.91",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 53% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.35",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.13",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","75.82",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (75.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (75.8%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","191.24",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.68",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.98",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.53",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","20.80",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","21.65",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.29",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.71",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.06",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.06 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","88.09",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","91.18",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.79",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.15",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 37.6 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.7% of the total average of 88.1 cycles between issuing two instructions."
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.8 threads being active per cycle. This is further reduced to 21.2 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'691.55",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'210'830",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'821.27",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'253'378",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 77598 fused and 60354 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.39",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.71",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.4%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","159'456",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","52.57",
"9","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 57953 excessive sectors (21% of the total 277685 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.49",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","40'071",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","21.76",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","21.76",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.50",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.46",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","12.08",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","36'990.74",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","69.54",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 15% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 55% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.36",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.12",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","75.27",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (75.3%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (75.3%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","198.27",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","12.08",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","21.76",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.89",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","20.44",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","22.50",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.25",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.75",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.97",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.97 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","87.51",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.64",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.84",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.21",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 37.5 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.8% of the total average of 87.5 cycles between issuing two instructions."
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.8 threads being active per cycle. This is further reduced to 21.2 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'613.01",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'185'066",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'742.01",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'227'380",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 75546 fused and 58758 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","73.90",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.47",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (73.9%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","155'808",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","51.18",
"10","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 56354 excessive sectors (21% of the total 270173 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.43",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","39'884",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","22.11",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","22.11",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.54",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.47",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","12.12",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","36'825.44",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","69.54",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 15% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 55% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.36",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.12",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","75.25",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (75.2%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (75.2%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","200.23",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","12.12",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","22.11",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.77",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","20.43",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","22.50",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.23",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.77",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.96",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.96 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","87.52",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.65",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.85",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.22",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 37.5 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.8% of the total average of 87.5 cycles between issuing two instructions."
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.9 threads being active per cycle. This is further reduced to 21.2 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'599.23",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'180'546",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'728.11",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'222'819",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 75186 fused and 58478 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.04",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.54",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.0%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","155'168",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","50.94",
"11","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 56412 excessive sectors (21% of the total 269416 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.46",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","39'915",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","21.69",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","21.69",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.47",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.47",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.93",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","36'580.30",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","68.89",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 15% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 54% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.36",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.13",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","75.12",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (75.1%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (75.1%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","196.94",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.93",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","21.69",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","21.54",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","20.02",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","22.29",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.27",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.73",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.98",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.98 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","87.50",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.65",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.87",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.24",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 37.4 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.7% of the total average of 87.5 cycles between issuing two instructions."
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.9 threads being active per cycle. This is further reduced to 21.2 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'575.11",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'172'636",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'703.78",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'214'839",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 74556 fused and 57988 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.18",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.61",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.2%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","154'048",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","50.51",
"12","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 56226 excessive sectors (21% of the total 267440 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.46",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","39'934",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","21.36",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","21.36",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.50",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.46",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.85",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","36'345.34",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","68.28",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 54% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.36",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.12",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.97",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (75.0%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (75.0%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","194.02",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.85",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","21.36",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","21.40",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","20.11",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","22.09",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.26",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.74",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.97",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.97 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","87.36",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.52",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.89",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.26",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 37.3 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.7% of the total average of 87.4 cycles between issuing two instructions."
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.9 threads being active per cycle. This is further reduced to 21.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'551.34",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'164'839",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'679.81",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'206'978",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 73935 fused and 57505 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","73.78",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.41",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (73.8%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","152'944",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","50.09",
"13","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 56048 excessive sectors (21% of the total 265575 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.38",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.34",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","39'775",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","21.11",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","21.11",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.63",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.45",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.66",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","35'809.45",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","67.21",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 53% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.35",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.12",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.61",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (74.6%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (74.6%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","190.10",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.66",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","21.11",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","21.47",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.91",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","21.75",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.23",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.77",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.90",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.17",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.90 active warps per scheduler, but only an average of 0.17 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","87.04",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.23",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.94",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.31",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 37.1 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.7% of the total average of 87.0 cycles between issuing two instructions."
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.9 threads being active per cycle. This is further reduced to 21.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'495.87",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'146'646",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'623.85",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'188'622",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 72486 fused and 56378 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","73.97",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.51",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.0%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","150'368",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","49.11",
"14","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 55038 excessive sectors (21% of the total 260607 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.45",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","39'786",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.99",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.99",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.44",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.46",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.59",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","35'623.94",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","66.81",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 53% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.35",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.13",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.57",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (74.6%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (74.6%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","190.47",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.59",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.99",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","21.48",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.72",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","21.62",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.22",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.78",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.88",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.88 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","86.85",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.04",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.94",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.31",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 37.2 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.8% of the total average of 86.8 cycles between issuing two instructions."
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.9 threads being active per cycle. This is further reduced to 21.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'480.37",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'141'561",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'608.20",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'183'490",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 72081 fused and 56063 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","73.97",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.51",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.0%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","149'648",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","48.84",
"15","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 54418 excessive sectors (21% of the total 258572 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.48",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","39'859",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.74",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.74",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.41",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.46",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.47",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","35'250.30",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","65.82",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 52% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.35",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.13",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.37",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (74.4%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (74.4%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","188.75",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.47",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.74",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.94",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.92",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","21.29",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.27",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.73",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.96",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.96 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","87.23",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.46",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.97",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.34",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 37.0 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.4% of the total average of 87.2 cycles between issuing two instructions."
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.0 threads being active per cycle. This is further reduced to 21.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'443.85",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'129'583",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'571.39",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'171'415",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 71127 fused and 55321 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","73.73",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.39",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (73.7%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","147'952",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","48.19",
"16","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 53693 excessive sectors (21% of the total 255106 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.52",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","39'863",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.60",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.60",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.25",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.50",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.38",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","34'923.30",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","65.24",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 51% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.16",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.43",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (74.4%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (74.4%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","188.35",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.38",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.60",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.90",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.86",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","21.11",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.28",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.72",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.95",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.95 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","87.10",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.34",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.98",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.36",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 37.0 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.5% of the total average of 87.1 cycles between issuing two instructions."
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.0 threads being active per cycle. This is further reduced to 21.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'420.77",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'122'012",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'548.09",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'163'775",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 70524 fused and 54852 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","73.62",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.34",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (73.6%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","146'880",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","47.78",
"17","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 53229 excessive sectors (21% of the total 252910 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.49",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","39'994",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.61",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.61",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.44",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.57",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.26",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","34'334.46",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","64.06",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 51% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.22",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.59",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (74.6%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (74.6%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","187.86",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.26",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.61",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.38",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.78",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","20.73",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.29",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.71",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.92",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.92 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","86.69",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","89.94",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","22.01",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.39",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 36.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.5% of the total average of 86.7 cycles between issuing two instructions."
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.0 threads being active per cycle. This is further reduced to 21.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'381.15",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'109'017",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'508.10",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'150'658",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 69489 fused and 54047 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.08",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.56",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.1%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","145'040",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","47.08",
"18","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 52646 excessive sectors (21% of the total 249192 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.50",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","40'095",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.50",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.50",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.50",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.53",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.29",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","34'624.05",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","64.35",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 51% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.19",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.49",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (74.5%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (74.5%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","186.98",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.29",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.50",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.47",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.90",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","20.82",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.30",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.70",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.98",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.98 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","87.20",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.46",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","22.00",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.38",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 36.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.4% of the total average of 87.2 cycles between issuing two instructions."
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.0 threads being active per cycle. This is further reduced to 21.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'399.75",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'115'119",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'526.88",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'156'815",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 69975 fused and 54425 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","73.80",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.43",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (73.8%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","145'904",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","47.41",
"19","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 52506 excessive sectors (21% of the total 250781 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.53",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","40'028",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.32",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.32",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.34",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.56",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.26",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","34'294.35",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","63.84",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 50% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.21",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.46",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (74.5%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (74.5%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","185.87",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.26",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.32",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.03",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.86",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","20.65",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.32",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.68",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.97",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.97 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","86.84",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.11",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","22.03",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.41",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 36.7 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.3% of the total average of 86.8 cycles between issuing two instructions."
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.0 threads being active per cycle. This is further reduced to 21.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'373.23",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'106'418",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'500.12",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'148'039",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 69282 fused and 53886 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.24",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.64",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.2%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","144'672",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","46.94",
"20","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 51850 excessive sectors (21% of the total 248203 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.43",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","39'849",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.38",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.38",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.54",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.60",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.28",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","34'058.02",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","63.81",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 50% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.24",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.61",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (74.6%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (74.6%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","184.46",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.28",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.38",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","19.95",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.91",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","20.64",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.33",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.67",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.94",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.94 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","86.58",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","89.85",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","22.05",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.43",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 36.7 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.4% of the total average of 86.6 cycles between issuing two instructions."
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.0 threads being active per cycle. This is further reduced to 21.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'360.48",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'102'237",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'487.26",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'143'822",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 68949 fused and 53627 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.32",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.67",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.3%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","144'080",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","46.71",
"21","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 52075 excessive sectors (21% of the total 247741 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.46",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","39'681",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.37",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.37",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.31",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.62",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.26",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","33'846.60",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","63.69",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 13% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 50% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.40",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.26",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.63",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (74.6%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (74.6%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","185.07",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.26",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.37",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","19.95",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.80",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","20.61",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.34",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.66",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.98",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.98 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","86.84",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.12",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","22.06",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.44",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 36.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.4% of the total average of 86.8 cycles between issuing two instructions."
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.1 threads being active per cycle. This is further reduced to 21.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'344.63",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'097'039",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'471.26",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'138'573",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 68535 fused and 53305 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.57",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.79",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.6%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","143'344",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","46.43",
"22","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 51513 excessive sectors (21% of the total 246038 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.46",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","39'731",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.30",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.30",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.38",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.62",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.22",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","33'735",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","63.35",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 13% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 50% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.40",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.26",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.55",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (74.6%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (74.6%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","184.34",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.22",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.30",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.00",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.71",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","20.49",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.34",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.66",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.97",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.97 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","86.82",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.12",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","22.08",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.46",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 36.7 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.3% of the total average of 86.8 cycles between issuing two instructions."
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.1 threads being active per cycle. This is further reduced to 21.5 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'333.26",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'093'310",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'459.80",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'134'814",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 68238 fused and 53074 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.54",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.78",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.5%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","142'816",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","46.23",
"23","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 51731 excessive sectors (21% of the total 245683 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.47",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","39'679",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.14",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.14",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.28",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.66",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.05",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","33'212.20",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","62.36",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 13% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 49% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.40",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.28",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.46",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (74.5%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (74.5%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","183.08",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.05",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.14",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.06",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.62",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","20.17",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.37",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.63",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.98",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.98 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","86.61",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","89.93",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","22.12",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.50",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 36.6 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.2% of the total average of 86.6 cycles between issuing two instructions."
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.1 threads being active per cycle. This is further reduced to 21.5 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'289.51",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'078'959",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'415.66",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'120'335",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 67095 fused and 52185 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.55",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.78",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.5%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","140'784",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","45.46",
"24","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 50969 excessive sectors (21% of the total 241799 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.43",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","39'460",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","19.98",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","19.98",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.25",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.66",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","10.89",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","32'531.41",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","61.10",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 13% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 48% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.40",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.30",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.08",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (74.1%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (74.1%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","180.84",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","10.89",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","19.98",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","19.85",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.47",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","19.77",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.38",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.62",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.95",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.95 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","86.23",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","89.59",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","22.19",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.57",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 36.5 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.3% of the total average of 86.2 cycles between issuing two instructions."
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.2 threads being active per cycle. This is further reduced to 21.6 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'224.05",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'057'489",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'349.63",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'098'678",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 65385 fused and 50855 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.62",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.82",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.6%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","137'744",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","44.30",
"25","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 49832 excessive sectors (21% of the total 236107 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.44",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","39'364",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","19.15",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","19.15",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.15",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.74",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","10.53",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","31'394.34",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","58.92",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 13% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 46% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.40",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.32",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.36",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","73.82",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (73.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (73.8%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","173.54",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","10.53",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","19.15",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","19.80",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.18",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","19.06",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.42",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.58",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.95",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.95 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","85.92",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","89.34",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","22.29",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.67",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 36.3 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.2% of the total average of 85.9 cycles between issuing two instructions."
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.3 threads being active per cycle. This is further reduced to 21.7 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'128.28",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'026'075",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'253.00",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'066'985",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 62883 fused and 48909 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.28",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.66",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.3%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","133'296",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","42.60",
"26","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 48071 excessive sectors (21% of the total 227518 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.36",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.34",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","33'310",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","21.47",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","21.47",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","24.86",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.60",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.70",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","30'076.96",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","65.02",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 51% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.36",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.28",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","71.95",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (72.0%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (72.0%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","192.98",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.70",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","21.47",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","19.75",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","18.69",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","21.04",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.37",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.63",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.85",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.85 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","85.31",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","88.85",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","22.46",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.86",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 35.5 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 41.6% of the total average of 85.3 cycles between issuing two instructions."
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.5 threads being active per cycle. This is further reduced to 21.9 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","2'968.77",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","973'756",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'092.08",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'014'202",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 58716 fused and 45668 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","73.76",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.41",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (73.8%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","125'888",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","39.78",
"27","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 45634 excessive sectors (21% of the total 213648 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.35",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.34",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","33'232",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","19.97",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","19.97",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","24.83",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.66",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","10.78",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","28'124.41",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","59.97",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 13% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 47% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.40",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.35",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","70.81",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (70.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (70.8%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","179.23",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","10.78",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","19.97",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","19.50",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","18.32",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","19.40",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.47",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.53",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.85",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.85 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","84.58",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","88.28",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","22.66",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","22.07",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 34.7 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 41.0% of the total average of 84.6 cycles between issuing two instructions."
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.7 threads being active per cycle. This is further reduced to 22.1 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","2'789.62",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","914'996",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","2'911.36",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","954'927",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 54036 fused and 42028 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","73.52",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.29",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (73.5%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","117'568",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","36.61",
"28","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 41934 excessive sectors (21% of the total 196723 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.38",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.34",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","32'919",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","18.37",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","18.37",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","24.54",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.99",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","9.91",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","25'368.76",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","54.22",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 12% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 43% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.41",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.31",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.62",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.42",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","70.32",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (70.3%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (70.3%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","165.46",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","9.91",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","18.37",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","19.27",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","17.44",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","17.54",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.74",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.11",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.26",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.92",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.3 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.92 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","83.06",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","86.93",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","22.95",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","22.37",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 33.7 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 40.6% of the total average of 83.1 cycles between issuing two instructions."
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.9 threads being active per cycle. This is further reduced to 22.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","2'573.96",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","844'258",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","2'693.78",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","883'559",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 48402 fused and 37646 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","73.95",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.49",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (73.9%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","107'552",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","32.79",
"29","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 37913 excessive sectors (21% of the total 176746 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.33",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.33",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","26'965",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","19.41",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","19.41",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","20.19",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.72",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","10.39",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","23'052.99",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","56.37",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 12% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 44% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.40",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.48",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.42",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","65.87",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (65.9%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (65.9%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","173.86",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","10.39",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","19.41",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","19.08",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.53",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","18.24",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.65",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.11",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.35",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.82",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.19",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.4 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.82 active warps per scheduler, but only an average of 0.19 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","82.77",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","86.99",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","23.38",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","22.83",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 32.0 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 38.7% of the total average of 82.8 cycles between issuing two instructions."
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 23.4 threads being active per cycle. This is further reduced to 22.8 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","2'298.35",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","753'858",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","2'415.74",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","792'362",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 41202 fused and 32046 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","72.57",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","34.83",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (72.6%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","94'752",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","27.91",
"30","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 32186 excessive sectors (21% of the total 150484 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.41",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","26'874",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","16.06",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","16.06",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","19.97",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","15.32",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","8.72",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","19'177.56",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","45.55",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 10% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.42",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.30",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.98",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.44",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","63.79",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (63.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (63.8%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","145.06",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","8.72",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","16.06",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.30",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","15.84",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","14.74",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","11.15",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.11",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","88.85",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.01",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.20",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.0 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.01 active warps per scheduler, but only an average of 0.20 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","80.79",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","85.44",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","23.99",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","23.48",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 29.7 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 36.7% of the total average of 80.8 cycles between issuing two instructions."
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 24.8 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 30.7% of the total average of 80.8 cycles between issuing two instructions."
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 24.0 threads being active per cycle. This is further reduced to 23.5 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","1'991.73",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","653'288",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","2'106.41",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","690'904",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 33192 fused and 25816 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.62",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.82",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.6%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.12",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","80'512",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","22.49",
"31","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 26438 excessive sectors (22% of the total 121871 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.23",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.32",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","20'035",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","17.25",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","17.25",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","15.17",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","15.44",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","9.12",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","16'467.09",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","48.33",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 10% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 38% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.42",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","11.08",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.44",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","58.74",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","FP64 is the highest-utilized pipeline (58.7%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. It is well-utilized, but should not be a bottleneck."
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","152.84",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","9.12",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","17.25",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.12",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","15.71",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","15.64",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","11.43",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.11",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","88.57",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.55",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.21",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 8.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.55 active warps per scheduler, but only an average of 0.21 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","74.78",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","79.04",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","24.70",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","24.23",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 27.3 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 36.5% of the total average of 74.8 cycles between issuing two instructions."
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","1'725.77",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","566'052",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","1'824.04",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","598'286",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 26244 fused and 20412 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","69.59",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","33.40",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (69.6%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.12",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","68'160",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","17.78",
"32","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 20695 excessive sectors (22% of the total 96251 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.37",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.34",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","19'394",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","12.74",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","12.74",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","14.46",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","17.71",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","6.76",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","11'809.60",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","34.84",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 7% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.48",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.29",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","12.67",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.51",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","57.16",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","FP64 is the highest-utilized pipeline (57.2%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. It is well-utilized, but should not be a bottleneck."
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","114.62",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","6.76",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","12.74",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.73",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","14.72",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","11.27",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","13.13",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.13",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","86.87",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.40",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.24",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 7.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.40 active warps per scheduler, but only an average of 0.24 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","63.97",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","67.30",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","25.82",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","25.42",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 23.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 37.3% of the total average of 64.0 cycles between issuing two instructions."
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","1'422.25",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","466'499",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","1'496.20",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","490'755",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 18315 fused and 14245 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","68.12",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","32.70",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (68.1%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.12",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","54'064",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","12.41",
"33","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 14308 excessive sectors (21% of the total 67058 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.38",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.34",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","18'852",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","9.39",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","9.16",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","14.05",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","20.34",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","4.77",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","8'688.39",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.71",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 5% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.55",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.26",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","14.55",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.58",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","53.56",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","FP64 is the highest-utilized pipeline (53.6%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. It is well-utilized, but should not be a bottleneck."
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","82.52",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","5.63",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","9.39",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.03",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","15.18",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","9.39",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","15.15",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.15",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","84.85",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.14",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.27",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 6.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.14 active warps per scheduler, but only an average of 0.27 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","53.74",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","56.40",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","26.97",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","26.64",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 20.3 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 37.8% of the total average of 53.7 cycles between issuing two instructions."
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","1'204.52",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","395'083",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","1'264.21",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","414'661",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 12627 fused and 9821 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","66.63",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","31.98",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (66.6%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.11",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","43'952",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","8.55",
"34","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 10035 excessive sectors (22% of the total 46393 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.26",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.32",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","18'252",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","8.32",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","6.20",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","13.79",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","23.91",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","3.25",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","6'346.20",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","16.62",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 4% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.65",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.23",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","17.10",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.68",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","47.77",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","FP64 is the highest-utilized pipeline (47.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. It is well-utilized, but should not be a bottleneck."
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","55.16",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","4.79",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","8.32",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.33",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","15.34",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","8.32",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","17.85",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.18",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","82.15",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.91",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.31",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 5.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.91 active warps per scheduler, but only an average of 0.31 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","44.31",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","46.43",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","28.19",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","27.95",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 16.3 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 36.9% of the total average of 44.3 cycles between issuing two instructions."
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","1'036.05",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","339'826",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","1'085.48",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","356'036",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 8226 fused and 6398 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","64.79",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","31.10",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (64.8%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.11",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","36'128",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","5.57",
"35","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 6339 excessive sectors (21% of the total 30043 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.38",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.34",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","18'243",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","7.39",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","4.05",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","13.63",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","27.86",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","2.15",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","4'833.48",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","10.57",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 2% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.76",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.20",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","19.96",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.80",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","39.87",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","FP64 is the highest-utilized pipeline (39.9%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. It is well-utilized, but should not be a bottleneck."
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","36.45",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","4.09",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","7.39",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.99",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.41",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","7.39",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","21.02",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.21",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","78.98",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.72",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.35",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 4.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.72 active warps per scheduler, but only an average of 0.35 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","36.71",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","38.44",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","29.28",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","29.10",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 12.8 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 34.8% of the total average of 36.7 cycles between issuing two instructions."
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","921.33",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","302'197",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","964.85",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","316'470",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 5229 fused and 4067 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","63.30",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","30.39",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (63.3%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.10",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","30'800",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","3.54",
"36","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 4178 excessive sectors (22% of the total 19254 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.34",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.34",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","18'054",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","6.78",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","2.40",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","13.50",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","32.75",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","1.35",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","3'736.43",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","6.78",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 1% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.90",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.19",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","23.49",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.94",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","30.27",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","FP64 is the highest-utilized pipeline (30.3%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. It is well-utilized, but should not be a bottleneck."
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","21.48",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","3.63",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","6.78",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.16",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","20.76",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","6.78",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","24.78",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.25",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","75.22",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.54",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.41",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 4.0 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.54 active warps per scheduler, but only an average of 0.41 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","30.45",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","31.87",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","30.24",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","30.13",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 9.6 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 31.4% of the total average of 30.5 cycles between issuing two instructions."
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","838.65",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","275'077",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","877.86",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","287'939",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 3069 fused and 2387 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","62.53",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","30.01",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (62.5%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.10",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","26'960",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","2.08",
"37","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 2359 excessive sectors (21% of the total 11200 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.29",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.33",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","18'066",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","6.32",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","1.31",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","13.60",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","37.62",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.82",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","3'030.38",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","6.32",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 1% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.03",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.17",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","27.00",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.08",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","27.00",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (22.7%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","11.70",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","3.29",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","6.32",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","16.88",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","27.92",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","6.32",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","28.77",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.29",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","71.23",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.11",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.47",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.11 active warps per scheduler, but only an average of 0.47 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","24.73",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","25.86",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.02",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","30.95",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","782.49",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","256'658",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","818.32",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","268'408",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 1602 fused and 1246 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","59.99",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","28.79",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (60.0%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","24'352",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","1.09",
"38","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 1434 excessive sectors (24% of the total 6042 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.37",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.34",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","18'159",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","6.06",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.70",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","13.54",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","41.68",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.52",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'635.74",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","6.06",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.15",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.17",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","29.91",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.20",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","29.91",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (25.5%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","6.31",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","3.10",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","6.06",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.14",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","38.82",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","6.06",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","31.86",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.32",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","68.14",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.12",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.53",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.1 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.12 active warps per scheduler, but only an average of 0.53 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","22.36",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","23.37",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.45",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.41",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","754.59",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","247'505",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","788.43",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","258'606",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 873 fused and 679 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","60.06",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","28.83",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (60.1%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","23'056",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.59",
"39","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 723 excessive sectors (22% of the total 3245 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.31",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.33",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","18'053",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","5.97",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.41",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","13.54",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","43.83",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.38",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'457.65",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","5.97",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.20",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.16",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","31.45",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.26",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","31.45",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (27.1%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","3.71",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","3.03",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","5.97",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","16.79",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","50.39",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","5.97",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","33.56",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.34",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","66.44",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","6.91",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.0 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 6.91 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","20.58",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","21.50",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.68",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.66",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 7.1 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 34.4% of the total average of 20.6 cycles between issuing two instructions."
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","740.12",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","242'759",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","772.95",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","253'529",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 495 fused and 385 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","58.22",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","27.94",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (58.2%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","22'384",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.34",
"40","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 466 excessive sectors (25% of the total 1896 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.22",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.32",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","15'439",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","6.92",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.30",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","11.68",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","45.28",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.72",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'354.89",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","6.92",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.24",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.19",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","32.50",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.30",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","32.50",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (28.1%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","2.62",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","3.49",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","6.92",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","16.87",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","29.81",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","6.92",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","34.97",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.35",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","65.03",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.06",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.57",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.9 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.06 active warps per scheduler, but only an average of 0.57 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","20.19",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","21.08",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.80",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.79",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 6.4 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 31.6% of the total average of 20.2 cycles between issuing two instructions."
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","732.88",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","240'386",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","765.28",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","251'012",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 306 fused and 238 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","59.97",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","28.79",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (60.0%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","22'048",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.21",
"41","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 267 excessive sectors (23% of the total 1146 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","8.73",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.25",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","9'147",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","11.56",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.18",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","7.33",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","46.68",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.41",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'261.45",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","11.56",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.28",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.32",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","33.49",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.34",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","33.49",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (29.1%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","1.54",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","5.80",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","11.56",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.31",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","81.07",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","11.56",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","35.92",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.36",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","64.08",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","6.84",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.59",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 6.84 active warps per scheduler, but only an average of 0.59 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","19.05",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","19.88",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.92",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.92",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 6.3 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 33.0% of the total average of 19.0 cycles between issuing two instructions."
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","725.65",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","238'013",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","757.47",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","248'451",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 117 fused and 91 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","58.19",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","27.93",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (58.2%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","21'712",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.08",
"42","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 80 excessive sectors (19% of the total 418 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","8.22",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.18",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","7'167",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","14.70",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.11",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","6.08",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","46.63",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.47",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'255.93",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","14.70",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.28",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.40",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","33.46",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.34",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","33.46",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (29.1%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Mbyte/second","884.21",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","7.37",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","14.70",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.90",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","89.52",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","14.70",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","36.45",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.36",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","63.55",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","6.95",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.59",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 6.95 active warps per scheduler, but only an average of 0.59 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","19.07",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","19.91",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.96",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.96",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 6.5 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 34.0% of the total average of 19.1 cycles between issuing two instructions."
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","723.24",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","237'222",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","754.91",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","247'609",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 54 fused and 42 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","57.99",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","27.84",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (58.0%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","21'600",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.04",
"43","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 43 excessive sectors (22% of the total 199 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","8.23",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.17",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","6'649",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","15.82",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.04",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","5.66",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","46.85",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.46",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'241.06",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","15.82",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.29",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.44",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","33.62",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.34",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","33.62",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (29.3%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Mbyte/second","316.38",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","7.92",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","15.82",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","13.43",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","95.07",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","15.82",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.8 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","36.80",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.37",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","63.20",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","6.90",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.60",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 6.90 active warps per scheduler, but only an average of 0.60 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","18.75",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","19.57",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.99",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.99",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 6.4 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 34.3% of the total average of 18.7 cycles between issuing two instructions."
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","721.86",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","236'770",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","753.42",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","247'121",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 18 fused and 14 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","57.54",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","27.62",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (57.5%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","21'536",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.01",
"44","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 15 excessive sectors (22% of the total 67 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","8.72",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.24",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","6'492",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","16.20",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.02",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","5.22",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","47.14",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.46",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'226.38",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","16.20",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.30",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.45",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","33.82",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.35",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","33.82",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (29.5%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Mbyte/second","147.24",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","8.10",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","16.20",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","13.33",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","97.05",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","16.20",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.4 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","36.99",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.37",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","63.01",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","6.98",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.60",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 6.98 active warps per scheduler, but only an average of 0.60 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","18.86",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","19.68",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.99",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.99",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 6.6 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 35.2% of the total average of 18.9 cycles between issuing two instructions."
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","721.52",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","236'657",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","753.04",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","246'998",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 9 fused and 7 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","58.39",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","28.03",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (58.4%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","21'520",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.01",
"45","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 4 excessive sectors (13% of the total 30 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.16",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.31",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","6'863",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","15.30",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.02",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","5.22",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","47.06",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.44",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'229.90",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","15.30",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.29",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.42",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","33.77",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.35",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","33.77",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (29.4%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Mbyte/second","147.24",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","7.66",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","15.30",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","13.33",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","97.12",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","15.30",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.4 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","36.94",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.37",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","63.06",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.02",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.60",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.02 active warps per scheduler, but only an average of 0.60 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","19.01",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","19.84",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.99",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.99",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 6.3 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 33.0% of the total average of 19.0 cycles between issuing two instructions."
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","721.52",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","236'657",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","753.04",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","246'998",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 9 fused and 7 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","58.09",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","27.88",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (58.1%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","21'520",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.01",
"46","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 4 excessive sectors (13% of the total 30 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","8.15",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.16",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","6'528",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","16.11",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.05",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","5.60",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","47.29",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.47",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'220.21",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","16.11",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.30",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.44",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","33.93",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.36",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","33.93",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (29.5%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Mbyte/second","388.57",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","8.06",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","16.11",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","13.43",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","96.17",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","16.11",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.8 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","37.14",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.37",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","62.86",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.11",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.60",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.11 active warps per scheduler, but only an average of 0.60 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","19.15",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","19.98",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.99",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.99",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 7.3 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 38.3% of the total average of 19.1 cycles between issuing two instructions."
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","721.86",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","236'770",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","753.42",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","247'121",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 18 fused and 14 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","58.69",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","28.17",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (58.7%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","21'536",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.01",
"47","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 15 excessive sectors (22% of the total 67 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","8.35",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.19",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","7'925",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","13.29",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.10",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","6.62",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","46.52",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.43",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'261.56",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","13.29",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.28",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.37",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","33.38",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.34",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","33.38",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (29.0%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Mbyte/second","792.27",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","6.66",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","13.29",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","16.06",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","89.38",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","13.29",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","36.05",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.36",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","63.95",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","6.80",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.58",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 6.80 active warps per scheduler, but only an average of 0.58 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","18.85",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","19.67",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.96",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.96",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 6.5 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 34.3% of the total average of 18.8 cycles between issuing two instructions."
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","723.35",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","237'258",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","755.02",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","247'645",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 61 fused and 46 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 21% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","56.92",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","27.32",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (56.9%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","21'605",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.31",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.04",
"48","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 43 excessive sectors (22% of the total 199 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","8.74",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.25",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","9'912",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","10.67",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.16",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","7.90",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","46.31",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.38",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'279.50",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","10.67",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.27",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.29",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","33.24",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.33",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","33.24",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (28.9%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","1.38",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","5.36",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","10.67",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.45",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","81.29",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","10.67",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","36.01",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.36",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","63.99",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","6.93",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.59",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 6.93 active warps per scheduler, but only an average of 0.59 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","19.25",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","20.10",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.91",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.90",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 6.4 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 33.4% of the total average of 19.3 cycles between issuing two instructions."
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","725.98",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","238'121",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","757.80",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","248'558",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 138 fused and 103 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 21% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","57.59",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","27.65",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (57.6%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","21'727",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.84",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.08",
"49","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 80 excessive sectors (19% of the total 418 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.31",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.33",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","17'046",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","6.26",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.27",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","12.80",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","44.90",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.31",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'374.95",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","6.26",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.24",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.17",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","32.25",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.29",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","32.25",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (27.9%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","2.37",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","3.15",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","6.26",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","16.86",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","62.47",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","6.26",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","34.65",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.35",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","65.35",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","6.91",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.57",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.9 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 6.91 active warps per scheduler, but only an average of 0.57 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","19.95",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","20.83",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.77",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.76",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 6.3 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 31.8% of the total average of 19.9 cycles between issuing two instructions."
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","733.54",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","240'602",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","765.94",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","251'228",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 348 fused and 262 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 21% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","58.62",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","28.14",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (58.6%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","22'078",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.39",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.21",
"50","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 267 excessive sectors (23% of the total 1146 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.37",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.34",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","19'871",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","5.43",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.38",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","14.82",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","43.49",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.35",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'476.90",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","5.43",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.20",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.15",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","31.26",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.25",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","31.26",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (26.9%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","3.42",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","2.75",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","5.43",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","16.85",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","50.27",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","5.43",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","33.76",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.34",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","66.24",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.05",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.0 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.05 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","20.89",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","21.81",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.63",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.60",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 6.5 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 31.0% of the total average of 20.9 cycles between issuing two instructions."
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","741.44",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","243'191",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","774.24",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","253'951",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 579 fused and 433 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 21% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","58.78",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","28.21",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (58.8%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","22'444",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.74",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.34",
"51","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 466 excessive sectors (25% of the total 1896 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.34",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.33",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","19'639",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","5.60",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.65",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","14.72",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","40.73",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.62",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'697.59",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","5.60",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.12",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.15",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","29.28",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.17",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","29.28",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (25.0%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","5.83",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","2.86",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","5.60",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.15",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","30.58",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","5.60",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","31.73",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.32",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","68.27",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.13",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.52",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.2 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.13 active warps per scheduler, but only an average of 0.52 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","22.46",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","23.47",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.39",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.35",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","756.02",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","247'973",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","789.83",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","259'063",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 964 fused and 731 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","58.41",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","28.04",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (58.4%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","23'121",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.03",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.59",
"52","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 723 excessive sectors (22% of the total 3245 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.37",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.34",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","20'607",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","5.54",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","1.15",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","15.36",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","36.15",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.85",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","3'154.18",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","5.54",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 1% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.00",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.15",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","26.07",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.04",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","26.07",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (21.9%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","10.37",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","2.88",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","5.54",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","16.93",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","23.66",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","5.54",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","28.06",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","71.94",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.25",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.46",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.25 active warps per scheduler, but only an average of 0.46 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","25.83",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","27.01",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","30.87",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","30.80",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","786.45",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","257'954",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","822.27",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","269'704",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 1854 fused and 1390 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 21% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","59.09",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","28.36",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (59.1%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.10",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","24'532",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.61",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","1.09",
"53","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 1434 excessive sectors (24% of the total 6042 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.33",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.33",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","20'009",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","6.12",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","2.16",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","14.98",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.31",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","1.21",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","3'907.89",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","6.23",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 1% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.86",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.17",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","22.59",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.90",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","31.87",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","FP64 is the highest-utilized pipeline (31.9%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. It is well-utilized, but should not be a bottleneck."
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","19.38",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","3.28",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","6.12",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.17",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","20.98",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","6.12",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","24.00",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.24",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","76.00",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.40",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.40",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 4.2 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.40 active warps per scheduler, but only an average of 0.40 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","30.84",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","32.28",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","30.07",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","29.96",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 9.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 32.1% of the total average of 30.8 cycles between issuing two instructions."
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","843.59",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","276'697",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","882.76",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","289'546",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 3384 fused and 2567 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","60.26",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","28.93",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (60.3%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.10",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","27'185",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.01",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","2.08",
"54","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 2359 excessive sectors (21% of the total 11200 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.32",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.33",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","20'464",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","6.59",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","3.62",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","15.36",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","26.48",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","2.05",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","5'084.49",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","10.47",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 2% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.73",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.18",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","19.16",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.77",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","42.09",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","FP64 is the highest-utilized pipeline (42.1%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. It is well-utilized, but should not be a bottleneck."
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","32.37",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","3.65",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","6.59",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.01",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","15.38",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","6.59",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","20.23",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.20",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","79.77",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.66",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.34",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 4.9 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.66 active warps per scheduler, but only an average of 0.34 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","37.89",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","39.66",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","29.00",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","28.82",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 13.5 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 35.6% of the total average of 37.9 cycles between issuing two instructions."
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","930.55",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","305'221",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","973.97",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","319'463",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 5817 fused and 4403 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","62.77",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","30.13",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (62.8%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.10",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","31'220",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.12",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","3.54",
"55","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 4178 excessive sectors (22% of the total 19254 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.42",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","21'254",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","7.14",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","5.34",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","15.78",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","22.64",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","2.92",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","6'702.55",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","15.65",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.63",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.20",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","16.38",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.66",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","49.59",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","FP64 is the highest-utilized pipeline (49.6%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. It is well-utilized, but should not be a bottleneck."
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","48.28",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","4.11",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","7.14",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.34",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","14.71",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","7.14",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","17.29",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.17",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","82.71",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.85",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.30",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 5.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.85 active warps per scheduler, but only an average of 0.30 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","45.38",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","47.52",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","27.86",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","27.62",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 17.1 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 37.7% of the total average of 45.4 cycles between issuing two instructions."
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","1'048.68",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","343'966",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","1'097.99",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","360'142",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 9031 fused and 6858 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","63.62",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","30.54",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (63.6%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.11",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","36'703",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","78.95",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","5.57",
"56","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 6339 excessive sectors (21% of the total 30043 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.42",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","21'085",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","8.39",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","8.19",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","15.65",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","19.22",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","4.40",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","9'195.11",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","23.98",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 5% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.53",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.23",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","13.93",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.56",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","54.94",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","FP64 is the highest-utilized pipeline (54.9%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. It is well-utilized, but should not be a bottleneck."
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","74.08",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","5.03",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","8.39",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.01",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","14.78",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","8.39",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","14.67",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.15",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","85.33",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.09",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.26",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 6.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.09 active warps per scheduler, but only an average of 0.26 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","55.13",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","57.81",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","26.60",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","26.28",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 21.1 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 38.3% of the total average of 55.1 cycles between issuing two instructions."
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","1'221.75",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","400'735",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","1'281.26",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","420'254",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 13726 fused and 10449 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","65.22",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","31.30",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (65.2%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.11",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","44'737",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","78.83",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","8.55",
"57","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 10035 excessive sectors (22% of the total 46393 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.37",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.34",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","21'551",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","11.45",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","11.45",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","16.10",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","16.78",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","6.08",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","12'463.57",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","33.81",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 7% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.46",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.27",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","12.19",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.49",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","58.41",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","FP64 is the highest-utilized pipeline (58.4%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. It is well-utilized, but should not be a bottleneck."
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","103.01",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","6.08",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","11.45",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.72",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","14.71",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","10.85",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","12.71",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.13",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","87.29",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.27",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.23",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 7.9 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.27 active warps per scheduler, but only an average of 0.23 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","65.03",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","68.35",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","25.42",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","25.03",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 24.8 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 38.1% of the total average of 65.0 cycles between issuing two instructions."
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","1'445.19",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","474'023",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","1'519.01",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","498'236",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 19778 fused and 15081 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","66.73",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","32.03",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (66.7%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.12",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","55'109",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","78.75",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","12.41",
"58","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 14308 excessive sectors (21% of the total 67058 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.37",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.34",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","22'864",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","15.11",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","15.11",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","17.06",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.56",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","8.15",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","17'456.56",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","45.58",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 9% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.40",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.31",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.64",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.43",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","59.65",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","FP64 is the highest-utilized pipeline (59.7%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. It is well-utilized, but should not be a bottleneck."
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","135.89",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","8.15",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","15.11",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.11",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","15.48",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","14.63",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","11.06",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.11",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","88.94",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.43",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.20",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.0 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.43 active warps per scheduler, but only an average of 0.20 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","76.24",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","80.53",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","24.27",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","23.81",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 28.3 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 37.1% of the total average of 76.2 cycles between issuing two instructions."
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 24.3 threads being active per cycle. This is further reduced to 23.8 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","1'757.82",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","576'564",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","1'856.65",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","608'980",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 28288 fused and 21580 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","68.14",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","32.70",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (68.1%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.12",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","69'620",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","78.72",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","17.78",
"59","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 20695 excessive sectors (22% of the total 96251 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.25",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.32",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","28'533",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","15.12",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","15.12",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","21.57",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.23",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","8.14",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","20'644.56",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","45.45",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 9% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.28",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.36",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","62.77",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (62.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (62.8%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","134.29",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","8.14",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","15.12",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.34",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","15.80",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","14.61",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.63",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.11",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.37",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.71",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.19",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.4 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.71 active warps per scheduler, but only an average of 0.19 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","81.92",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","86.57",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","23.63",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","23.13",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 30.3 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 37.0% of the total average of 81.9 cycles between issuing two instructions."
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 23.6 threads being active per cycle. This is further reduced to 23.1 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","2'023.12",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","663'584",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","2'138.15",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","701'313",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 35194 fused and 26960 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","71.53",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","34.33",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (71.5%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.12",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","81'942",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","78.52",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","22.49",
"60","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 26438 excessive sectors (22% of the total 121871 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.42",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","29'248",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","17.88",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","17.88",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","21.70",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.97",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","9.58",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","24'299.38",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","54.67",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 11% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 44% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.38",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.32",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.08",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","65.76",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (65.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (65.8%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","161.76",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","9.58",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","17.88",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","19.13",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.53",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","17.59",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.37",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.63",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.61",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.61 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","82.95",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","87.13",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","23.05",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","22.50",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 32.5 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 39.2% of the total average of 83.0 cycles between issuing two instructions."
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 23.0 threads being active per cycle. This is further reduced to 22.5 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","2'332.70",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","765'126",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","2'450.32",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","803'706",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 43393 fused and 33298 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","70.04",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","33.62",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (70.0%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","96'317",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","78.43",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","27.91",
"61","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 32186 excessive sectors (21% of the total 150484 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.40",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","36'144",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","16.75",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","16.75",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","26.85",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.18",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","9.05",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","26'827.46",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","51.45",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 11% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 41% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.29",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.16",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","69.29",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (69.3%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (69.3%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","151.21",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","9.05",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","16.75",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","19.32",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","17.40",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","16.57",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.37",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.63",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.53",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.53 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","82.26",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","86.06",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","22.67",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","22.10",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 33.8 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 41.1% of the total average of 82.3 cycles between issuing two instructions."
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.7 threads being active per cycle. This is further reduced to 22.1 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","2'606.34",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","854'878",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","2'726.66",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","894'344",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 50467 fused and 38826 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","70.07",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","33.64",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (70.1%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","109'027",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","78.31",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","32.79",
"62","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 37913 excessive sectors (21% of the total 176746 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.10",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.30",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","35'523",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","18.72",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","18.72",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","27.26",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.12",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","10.17",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","29'215.94",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","57.83",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 12% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 46% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.32",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.06",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","70.28",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (70.3%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (70.3%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","163.62",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","10.17",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","18.72",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","19.54",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","18.15",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","18.65",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.17",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.83",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.63",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.63 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","84.87",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","88.55",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","22.46",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.87",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 35.1 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 41.4% of the total average of 84.9 cycles between issuing two instructions."
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.5 threads being active per cycle. This is further reduced to 21.9 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","2'816.29",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","923'744",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","2'938.36",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","963'783",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 55737 fused and 43000 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","71.57",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","34.35",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (71.6%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","118'783",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","78.17",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","36.61",
"63","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 41934 excessive sectors (21% of the total 196723 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.49",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","36'352",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","19.88",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","19.88",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","26.75",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.16",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","10.73",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","31'004.93",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","60.86",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 13% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 48% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.04",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","71.31",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (71.3%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (71.3%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","181.21",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","10.73",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","19.88",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","19.79",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","18.64",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","19.64",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.22",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.78",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.75",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.75 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","85.68",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","89.22",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","22.32",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.72",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 35.8 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 41.8% of the total average of 85.7 cycles between issuing two instructions."
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.3 threads being active per cycle. This is further reduced to 21.7 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","2'989.07",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","980'416",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'112.74",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'020'980",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 60011 fused and 46408 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","72.04",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","34.58",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (72.0%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","126'813",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","78.05",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","39.78",
"64","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 45634 excessive sectors (21% of the total 213648 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.78",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.40",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","41'381",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","18.25",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","18.25",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.57",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.35",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","10.02",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","32'241.82",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","57.11",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 12% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 45% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.30",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.15",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","73.24",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (73.2%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (73.2%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","171.44",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","10.02",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","18.25",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","19.85",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.17",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","18.44",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.29",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.71",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.86",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.86 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","86.10",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","89.52",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","22.16",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.55",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 36.4 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.3% of the total average of 86.1 cycles between issuing two instructions."
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.2 threads being active per cycle. This is further reduced to 21.6 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'147.16",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'032'267",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'272.17",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'073'273",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 64087 fused and 49597 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","73.13",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.10",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (73.1%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","134'156",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","78.02",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","42.60",
"65","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 48071 excessive sectors (21% of the total 227518 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.48",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","41'258",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","18.94",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","18.94",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","30.40",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.46",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","10.41",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","32'988.93",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","59.08",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 12% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 47% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.31",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.19",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","73.84",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (73.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (73.8%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","172.42",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","10.41",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","18.94",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","19.86",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.44",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","19.09",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.31",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.69",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.88",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.88 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","86.19",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","89.54",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","22.11",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.50",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 36.6 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.4% of the total average of 86.2 cycles between issuing two instructions."
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.1 threads being active per cycle. This is further reduced to 21.5 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'235.36",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'061'197",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'361.10",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'102'441",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 66106 fused and 51267 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","73.48",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.27",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (73.5%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","138'259",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.92",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","44.30",
"66","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 49832 excessive sectors (21% of the total 236107 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.37",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.34",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","40'559",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","19.63",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","19.63",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","30.24",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.56",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","10.82",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","33'421.30",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","61.53",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 13% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 49% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.25",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.60",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (74.6%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (74.6%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","176.62",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","10.82",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","19.63",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.09",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.58",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","19.89",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.32",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.68",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.94",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.94 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","86.64",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","89.96",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","22.06",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.45",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 36.8 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.5% of the total average of 86.6 cycles between issuing two instructions."
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.1 threads being active per cycle. This is further reduced to 21.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'298.29",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'081'839",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'424.57",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'123'260",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 67655 fused and 52505 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.33",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.68",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.3%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","141'184",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.88",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","45.46",
"67","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 50969 excessive sectors (21% of the total 241799 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.48",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","40'446",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","19.98",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","19.98",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.82",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.50",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.03",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","34'013.91",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","62.51",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 13% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 49% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.19",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.27",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (74.3%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (74.3%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","181.77",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.03",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","19.98",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.01",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.73",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","20.21",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.33",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.67",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.93",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.93 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","86.45",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","89.73",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","22.05",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.43",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 36.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.7% of the total average of 86.5 cycles between issuing two instructions."
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.0 threads being active per cycle. This is further reduced to 21.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'338.09",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'094'894",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'464.67",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'136'413",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 68546 fused and 53250 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","73.78",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.41",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (73.8%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","143'036",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.83",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","46.23",
"68","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 51731 excessive sectors (21% of the total 245683 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.55",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.37",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","40'472",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.00",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.00",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.60",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.54",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.04",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","34'029.02",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","62.65",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 13% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 49% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.21",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.45",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (74.4%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (74.4%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","183.44",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.04",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.00",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","19.97",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.79",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","20.26",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.32",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.68",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.96",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.96 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","86.88",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.17",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","22.04",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.42",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 36.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.4% of the total average of 86.9 cycles between issuing two instructions."
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.0 threads being active per cycle. This is further reduced to 21.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'347.81",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'098'083",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'474.55",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'139'652",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 68738 fused and 53421 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.00",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.52",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.0%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","143'489",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.82",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","46.43",
"69","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 51513 excessive sectors (21% of the total 246038 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.40",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","39'752",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.55",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.55",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.54",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.57",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.30",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","34'130.20",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","64.06",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 51% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.22",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.57",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (74.6%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (74.6%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","185.53",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.30",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.55",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","19.96",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.93",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","20.72",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.31",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.69",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.93",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.93 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","86.54",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","89.81",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","22.04",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.42",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 36.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.6% of the total average of 86.5 cycles between issuing two instructions."
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.0 threads being active per cycle. This is further reduced to 21.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'362.12",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'102'777",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'488.95",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'144'377",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 69054 fused and 53687 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.27",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.65",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.3%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","144'155",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.80",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","46.71",
"70","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 52075 excessive sectors (21% of the total 247741 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.49",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","40'326",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.44",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.44",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.70",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.60",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.16",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","34'201.23",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","63.45",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 13% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 50% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.24",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.76",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (74.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (74.8%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","186.12",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.16",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.44",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","19.99",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.86",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","20.52",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.31",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.69",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.93",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.93 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","86.67",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","89.93",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","22.02",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.40",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 36.8 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.5% of the total average of 86.7 cycles between issuing two instructions."
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.0 threads being active per cycle. This is further reduced to 21.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'374.65",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'106'886",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'501.58",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'148'519",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 69373 fused and 53938 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.29",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.66",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.3%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","144'737",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.79",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","46.94",
"71","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 51850 excessive sectors (21% of the total 248203 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.56",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.37",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","40'276",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.33",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.33",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.44",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.45",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.24",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","34'817.13",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","64.09",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 51% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.13",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.10",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (74.1%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (74.1%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","186.63",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.24",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.33",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.45",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.87",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","20.73",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.29",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.71",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.98",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.98 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","87.33",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.59",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","22.00",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.38",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 36.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.2% of the total average of 87.3 cycles between issuing two instructions."
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.0 threads being active per cycle. This is further reduced to 21.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'400.19",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'115'263",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'527.33",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'156'964",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 70003 fused and 54441 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","73.72",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.39",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (73.7%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","145'924",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","47.41",
"72","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 52506 excessive sectors (21% of the total 250781 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.46",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","39'698",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.52",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.52",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.34",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.55",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.34",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","34'381.50",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","64.59",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 51% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.20",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.52",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (74.5%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (74.5%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","186.33",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.34",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.52",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.38",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.74",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","20.90",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.31",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.69",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.95",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.95 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","86.83",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.09",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","22.00",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.38",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 36.8 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.4% of the total average of 86.8 cycles between issuing two instructions."
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.0 threads being active per cycle. This is further reduced to 21.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'381.59",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'109'161",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'508.56",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'150'807",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 69517 fused and 54063 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.14",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.59",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.1%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","145'060",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","47.08",
"73","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 52646 excessive sectors (21% of the total 249192 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.48",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","39'780",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.63",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.63",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.34",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.52",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.40",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","34'876.70",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","65.38",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 52% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.17",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.53",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (74.5%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (74.5%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","187.67",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.40",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.63",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.91",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.85",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","21.15",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.29",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.71",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.91",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.91 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","86.66",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","89.89",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.98",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.36",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 36.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.6% of the total average of 86.7 cycles between issuing two instructions."
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.0 threads being active per cycle. This is further reduced to 21.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'420.77",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'122'012",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'548.07",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'163'766",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 70524 fused and 54852 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","73.80",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.42",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (73.8%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","146'880",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","47.78",
"74","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 53229 excessive sectors (21% of the total 252910 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.45",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","39'767",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.81",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.81",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.41",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.46",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.50",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","35'244.07",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","65.99",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 52% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.35",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.13",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.39",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (74.4%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (74.4%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","188.86",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.50",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.81",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.93",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.93",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","21.35",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.26",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.74",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.96",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.96 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","87.36",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.59",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.97",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.34",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 37.0 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.4% of the total average of 87.4 cycles between issuing two instructions."
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.0 threads being active per cycle. This is further reduced to 21.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'443.96",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'129'619",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'571.46",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'171'439",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 71134 fused and 55325 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","73.88",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.46",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (73.9%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","147'957",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","48.19",
"75","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 53693 excessive sectors (21% of the total 255106 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.45",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","39'714",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","21.22",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","21.22",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.38",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.47",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.60",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","35'601.66",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","66.94",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 53% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.35",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.13",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.62",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (74.6%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (74.6%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","192.58",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.60",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","21.22",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","21.47",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.76",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","21.66",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.22",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.78",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.91",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.91 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","87.23",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.43",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.94",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.31",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 37.1 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.6% of the total average of 87.2 cycles between issuing two instructions."
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.9 threads being active per cycle. This is further reduced to 21.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'480.37",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'141'561",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'608.21",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'183'494",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 72081 fused and 56063 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.06",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.55",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.1%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","149'648",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","48.84",
"76","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 54418 excessive sectors (21% of the total 258572 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.45",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","40'007",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","21.15",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","21.15",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.57",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.42",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.61",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","35'884.48",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","66.84",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 53% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.35",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.10",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.45",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (74.4%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (74.4%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","191.95",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.61",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","21.15",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","21.46",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.92",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","21.62",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.23",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.77",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.94",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.94 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","87.32",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.52",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.94",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.31",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 37.1 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.5% of the total average of 87.3 cycles between issuing two instructions."
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.9 threads being active per cycle. This is further reduced to 21.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'495.87",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'146'646",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'623.83",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'188'617",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 72486 fused and 56378 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","73.65",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.35",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (73.7%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","150'368",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","49.11",
"77","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 55038 excessive sectors (21% of the total 260607 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.49",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","40'049",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","21.32",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","21.32",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.47",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.44",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.82",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","36'394.93",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","68.11",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 54% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.36",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.11",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.88",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (74.9%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (74.9%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","194.32",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.82",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","21.32",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","21.39",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","20.08",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","22.03",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.25",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.75",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.98",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.98 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","87.62",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.79",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.89",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.26",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 37.3 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.6% of the total average of 87.6 cycles between issuing two instructions."
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.9 threads being active per cycle. This is further reduced to 21.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'551.45",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'164'875",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'679.92",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'207'014",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 73942 fused and 57509 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.24",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.64",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.2%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","152'949",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","50.09",
"78","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 56048 excessive sectors (21% of the total 265575 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.48",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","39'936",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","21.55",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","21.55",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.44",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.44",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.91",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","36'637.62",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","68.86",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 15% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 54% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.36",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.11",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","75.00",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (75.0%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (75.0%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","196.12",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.91",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","21.55",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","21.55",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","20.08",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","22.28",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.23",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.77",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.95",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.95 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","87.50",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.65",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.87",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.24",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 37.4 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.7% of the total average of 87.5 cycles between issuing two instructions."
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.9 threads being active per cycle. This is further reduced to 21.2 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'575.11",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'172'636",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'703.78",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'214'841",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 74556 fused and 57988 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","73.99",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.51",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.0%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","154'048",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","50.51",
"79","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 56226 excessive sectors (21% of the total 267440 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.48",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","39'907",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","21.82",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","21.82",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.44",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.47",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","12.12",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","36'823.23",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","69.52",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 15% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 55% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.36",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.12",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","75.25",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (75.3%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (75.3%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","198.48",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","12.12",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","21.82",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.77",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","20.39",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","22.49",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.22",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.78",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.94",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.94 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","87.46",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.59",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.85",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.22",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 37.5 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.8% of the total average of 87.5 cycles between issuing two instructions."
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.9 threads being active per cycle. This is further reduced to 21.2 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'599.23",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'180'546",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'728.12",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'222'823",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 75186 fused and 58478 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.35",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.69",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.4%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","155'168",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","50.94",
"80","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 56412 excessive sectors (21% of the total 269416 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.47",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","40'028",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","21.81",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","21.81",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.54",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.45",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","12.10",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","37'017.12",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","69.62",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 15% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 55% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.36",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.11",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","75.22",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (75.2%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (75.2%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","198.20",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","12.10",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","21.81",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.87",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","20.44",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","22.52",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.25",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.75",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.97",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.97 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","87.45",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.58",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.84",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.21",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 37.5 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.8% of the total average of 87.5 cycles between issuing two instructions."
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.8 threads being active per cycle. This is further reduced to 21.2 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'613.01",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'185'066",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'742.02",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'227'384",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 75546 fused and 58758 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","73.85",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.45",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (73.8%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","155'808",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","51.18",
"81","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 56354 excessive sectors (21% of the total 270173 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.55",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.37",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","42'894",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.98",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.98",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","31.39",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.50",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.64",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","37'690.39",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","66.74",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 53% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.14",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","75.88",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (75.9%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (75.9%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","192.27",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.64",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.98",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.56",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","20.76",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","21.59",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.29",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.71",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.02",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.02 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","87.65",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.73",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.79",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.15",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 37.6 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.9% of the total average of 87.6 cycles between issuing two instructions."
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.8 threads being active per cycle. This is further reduced to 21.2 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'691.55",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'210'830",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'821.26",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'253'373",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 77598 fused and 60354 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.55",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.78",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.6%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","159'456",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","52.57",
"82","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 57953 excessive sectors (21% of the total 277685 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.49",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","40'144",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","22.37",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","22.37",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.57",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.51",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","12.38",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","37'452.10",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","70.83",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 15% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 56% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.37",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.15",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","75.83",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (75.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (75.8%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","203.71",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","12.38",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","22.37",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.51",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","21.01",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","22.92",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.28",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.72",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.03",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.03 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","87.88",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.98",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.80",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.16",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 37.6 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.8% of the total average of 87.9 cycles between issuing two instructions."
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.8 threads being active per cycle. This is further reduced to 21.2 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'670.88",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'204'050",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'800.40",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'246'532",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 77058 fused and 59934 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.38",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.70",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.4%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","158'496",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","52.21",
"83","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 58148 excessive sectors (21% of the total 276200 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.49",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","45'865",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.05",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.05",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","33.76",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.51",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.28",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","38'736.12",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","64.60",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 51% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.14",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","76.44",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (76.4%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (76.4%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","182.73",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.28",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.05",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.51",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","21.49",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","20.90",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.27",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.73",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.06",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.06 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","88.22",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","91.26",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.71",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.07",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 37.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.0% of the total average of 88.2 cycles between issuing two instructions."
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.7 threads being active per cycle. This is further reduced to 21.1 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'796.29",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'245'182",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'926.91",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'288'026",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 80334 fused and 62482 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.70",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.86",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.7%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","164'320",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","54.43",
"84","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 60365 excessive sectors (21% of the total 287631 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.52",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","45'860",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.10",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.10",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","33.66",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.50",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.29",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","38'765.34",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","64.63",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 51% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.13",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","76.40",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (76.4%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (76.4%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","183.70",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.29",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.10",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.56",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","21.41",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","20.91",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.26",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.74",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.06",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.06 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","88.25",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","91.29",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.71",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.08",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 37.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.0% of the total average of 88.3 cycles between issuing two instructions."
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.7 threads being active per cycle. This is further reduced to 21.1 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'796.98",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'245'408",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'927.60",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'288'254",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 80352 fused and 62496 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.78",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.89",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.8%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","164'352",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","54.44",
"85","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 60866 excessive sectors (21% of the total 288259 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.48",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","45'968",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.64",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.64",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","33.89",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.48",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.62",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","40'055.99",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","66.97",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 53% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.11",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","76.81",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (76.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (76.8%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","187.93",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.62",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.64",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.89",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","21.78",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","21.67",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.24",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.76",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.06",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.06 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","88.47",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","91.44",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.64",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","20.99",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 38.1 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.1% of the total average of 88.5 cycles between issuing two instructions."
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.6 threads being active per cycle. This is further reduced to 21.0 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'916.52",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'284'619",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","4'048.22",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'327'817",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 83475 fused and 64925 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.86",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.93",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.9%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","169'904",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","56.55",
"86","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 62970 excessive sectors (21% of the total 299002 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.56",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.37",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","46'312",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.64",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.64",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","33.89",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.47",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.63",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","40'353.94",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","67.00",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 53% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.10",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","76.85",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (76.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (76.8%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","189.36",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.63",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.64",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.79",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","21.96",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","21.68",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.21",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.79",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.06",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.06 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","88.73",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","91.70",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.62",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","20.98",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 38.2 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.0% of the total average of 88.7 cycles between issuing two instructions."
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.6 threads being active per cycle. This is further reduced to 21.0 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'942.02",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'292'981",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","4'073.93",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'336'249",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 84141 fused and 65443 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.75",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.88",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.7%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","171'088",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","57.01",
"87","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 63112 excessive sectors (21% of the total 301065 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.52",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","46'341",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","21.20",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","21.20",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","34.05",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.35",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","12.00",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","41'791.57",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","69.19",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 15% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 55% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.35",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.01",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","76.66",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (76.7%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (76.7%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","193.71",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","12.00",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","21.20",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.80",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","22.49",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","22.39",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.13",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.87",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.00",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.17",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.9 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.00 active warps per scheduler, but only an average of 0.17 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","88.80",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","91.72",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.55",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","20.90",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 38.3 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.2% of the total average of 88.8 cycles between issuing two instructions."
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.5 threads being active per cycle. This is further reduced to 20.9 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","4'048.47",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'327'898",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","4'181.35",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'371'483",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 86922 fused and 67606 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.46",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.74",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.5%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","176'032",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","58.89",
"88","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 65870 excessive sectors (21% of the total 311233 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.51",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","46'243",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","21.34",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","21.34",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","33.98",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.36",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","12.04",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","41'808.83",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","69.47",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 15% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 55% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.35",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.02",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","76.77",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (76.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (76.8%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","194.78",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","12.04",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","21.34",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","20.70",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","22.45",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","22.47",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.13",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.87",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.02",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.17",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.9 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.02 active warps per scheduler, but only an average of 0.17 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","89.09",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","92.01",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.55",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","20.90",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 38.4 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.1% of the total average of 89.1 cycles between issuing two instructions."
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.5 threads being active per cycle. This is further reduced to 20.9 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","4'054.67",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'329'932",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","4'187.59",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'373'531",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 87084 fused and 67732 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.59",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.80",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.6%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","176'320",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","59",
"89","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 64953 excessive sectors (21% of the total 310969 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.51",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","52'537",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.24",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.24",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","38.62",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.36",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.50",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","45'727.35",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","68.05",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 54% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","9.99",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","78.14",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (78.1%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (78.1%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","184.69",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.50",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.24",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","22.32",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","22.75",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","22.02",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.12",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.88",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.11",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.17",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.9 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.11 active warps per scheduler, but only an average of 0.17 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","90.01",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","92.77",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.33",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","20.68",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 39.1 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.5% of the total average of 90.0 cycles between issuing two instructions."
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.3 threads being active per cycle. This is further reduced to 20.7 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","4'432.26",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'453'780",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","4'568.52",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'498'474",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 96948 fused and 75404 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","74.94",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.97",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (74.9%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","193'856",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","65.68",
"90","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 71753 excessive sectors (21% of the total 344784 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.55",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","52'573",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.28",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.28",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","38.50",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.37",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.53",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","45'880.41",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","68.31",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 54% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","9.99",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","78.23",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (78.2%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (78.2%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","185.83",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.53",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.28",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","22.47",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","22.94",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","22.10",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.11",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.89",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.12",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.17",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.9 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.12 active warps per scheduler, but only an average of 0.17 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","90.19",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","92.96",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.32",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","20.67",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 39.2 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.5% of the total average of 90.2 cycles between issuing two instructions."
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.3 threads being active per cycle. This is further reduced to 20.7 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","4'448.79",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'459'204",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","4'585.20",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'503'946",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 97380 fused and 75740 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","75.15",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","36.07",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (75.1%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","194'624",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","65.98",
"91","3168736","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","7","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 72630 excessive sectors (21% of the total 346759 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
